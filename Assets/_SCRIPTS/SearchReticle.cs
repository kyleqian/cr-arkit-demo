using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR.iOS;

public class SearchReticle : MonoBehaviour {

    public enum FocusState {
        Initializing,
        Finding,
        Found
    }

    public GameObject searchingReticle;
    public GameObject moveDeviceUI;
    public GameObject tapToPlaceUI;
    public GameObject foundReticle;
    public GameObject lookAroundText;
    public GameObject problemText;
    public GameObject tapText;
    [SerializeField] Animator tapToPlaceAnimator;
    [SerializeField] Animator moveDeviceAnimator;
    const string k_FadeOffAnim = "FadeOff";
    const string k_FadeOnAnim = "FadeOn";
    private bool hideFoundReticle = false;
    public TapToPlaceManager tapToPlace;

    public bool HideReticle {
        get{
            return hideFoundReticle;
        }
        set{
            hideFoundReticle = value;
            if(hideFoundReticle){
                foundReticle.SetActive(false);
                tapText.SetActive (false);
                lookAroundText.SetActive (false);
                problemText.SetActive (false);
                searchingReticle.SetActive (false);
                tapToPlaceUI.SetActive(false);
            }
        }
    }

    //for editor version
    public float maxRayDistance = 30.0f;
    public LayerMask collisionLayerMask;
    public float findingReticleDist = 0.5f;

    private FocusState reticleState;
    public FocusState ReticleState { 
        get {
            return reticleState;
        }
        set {
            reticleState = value;
            if (!hideFoundReticle) {
                foundReticle.SetActive (reticleState == FocusState.Found);
                searchingReticle.SetActive (reticleState != FocusState.Found);

                if (tapToPlace.storyState == TapToPlaceManager.StoryState.BeforeFirstTap) {
                    tapText.SetActive (reticleState == FocusState.Found);
                    lookAroundText.SetActive (reticleState != FocusState.Found);
                    moveDeviceAnimator.SetTrigger(reticleState == FocusState.Found ? k_FadeOffAnim : k_FadeOnAnim);
                    tapToPlaceAnimator.SetTrigger(reticleState == FocusState.Found ? k_FadeOnAnim : k_FadeOffAnim);

                    // problemText.SetActive (reticleState != FocusState.Found);
                }
            } 

        } 
    }

    bool trackingInitialized;

    // Use this for initialization
    void Start () {
        ReticleState = FocusState.Initializing;
        trackingInitialized = true;
    }


    bool HitTestWithResultType (ARPoint point, ARHitTestResultType resultTypes)
    {
        List<ARHitTestResult> hitResults = UnityARSessionNativeInterface.GetARSessionNativeInterface ().HitTest (point, resultTypes);
        if (hitResults.Count > 0) {
            foreach (var hitResult in hitResults) {
                foundReticle.transform.position = UnityARMatrixOps.GetPosition (hitResult.worldTransform) + new Vector3(0f, 0.05f, 0f);
                foundReticle.transform.rotation = UnityARMatrixOps.GetRotation (hitResult.worldTransform);
                foundReticle.transform.LookAt (new Vector3 (Camera.main.transform.position.x, foundReticle.transform.position.y, Camera.main.transform.position.z));
                Debug.Log (string.Format ("x:{0:0.######} y:{1:0.######} z:{2:0.######}", foundReticle.transform.position.x, foundReticle.transform.position.y, foundReticle.transform.position.z));
                return true;
            }
        }
        return false;
    }

    // Update is called once per frame
    void Update () {
        //if (StateManager.Instance.currentState != StateManager.GameState.Story) {
        //    return;
        //}
        if (hideFoundReticle) {
            return;
        }
        //use center of screen for focusing
        Vector3 center = new Vector3(Screen.width/2, Screen.height/2, findingReticleDist);

        #if UNITY_EDITOR
        Ray ray = Camera.main.ScreenPointToRay (center);
        RaycastHit hit;

        //we'll try to hit one of the plane collider gameobjects that were generated by the plugin
        //effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
        if (Physics.Raycast (ray, out hit, maxRayDistance, collisionLayerMask)) {
            //we're going to get the position from the contact point
            foundReticle.transform.position = hit.point;
            Debug.Log (string.Format ("x:{0:0.######} y:{1:0.######} z:{2:0.######}", foundReticle.transform.position.x, foundReticle.transform.position.y, foundReticle.transform.position.z));

            //and the rotation from the transform of the plane collider
            ReticleState = FocusState.Found;
            foundReticle.transform.rotation = hit.transform.rotation;
            return;
        }
#endif
//#if UNITY_ANDROID
        //if (ARCoreSearchReticleHit(center))
        //{
        //    return;
        //}
        //#endif

#if UNITY_IOS
        var screenPosition = Camera.main.ScreenToViewportPoint(center);
        ARPoint point = new ARPoint {
        x = screenPosition.x,
        y = screenPosition.y
        };

        // prioritize reults types
        ARHitTestResultType[] resultTypes = {
        ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent, 
        // if you want to use infinite planes use this:
        //ARHitTestResultType.ARHitTestResultTypeExistingPlane,
        //ARHitTestResultType.ARHitTestResultTypeHorizontalPlane, 
        //ARHitTestResultType.ARHitTestResultTypeFeaturePoint
        }; 

        foreach (ARHitTestResultType resultType in resultTypes)
        {
            if (HitTestWithResultType (point, resultType))
            {
                ReticleState = FocusState.Found;
                return;
            }
        }
#endif

        //if you got here, we have not found a plane, so if camera is facing below horizon, display the focus "finding" square
        if (trackingInitialized) {
            ReticleState = FocusState.Finding;
            //check camera forward is facing downward
            if (Vector3.Dot(Camera.main.transform.forward, Vector3.down) > 0)
            {

                //position the focus finding square a distance from camera and facing up
                searchingReticle.transform.position = Camera.main.ScreenToWorldPoint(center);

                //vector from camera to focussquare
                Vector3 vecToCamera = searchingReticle.transform.position - Camera.main.transform.position;

                //find vector that is orthogonal to camera vector and up vector
                Vector3 vecOrthogonal = Vector3.Cross(vecToCamera, Vector3.up);

                //find vector orthogonal to both above and up vector to find the forward vector in basis function
                Vector3 vecForward = Vector3.Cross(vecOrthogonal, Vector3.up);


                searchingReticle.transform.rotation = Quaternion.LookRotation(vecForward,Vector3.up);

            }
            else
            {
                //we will not display finding square if camera is not facing below horizon
                searchingReticle.SetActive(false);
            }

        }

    }

    //#region ARCore
    //private bool ARCoreSearchReticleHit(Vector3 screenCenter)
    //{
    //    TrackableHit coreHit;
    //    TrackableHitFlags raycastFilter = TrackableHitFlags.PlaneWithinPolygon |
    //        TrackableHitFlags.FeaturePointWithSurfaceNormal;
    //    if (Frame.Raycast(screenCenter.x, screenCenter.y, raycastFilter, out coreHit))
    //    {
    //        // Use hit pose and camera pose to check if hittest is from the
    //        // back of the plane, if it is, no need to create the anchor.
    //        if ((coreHit.Trackable is DetectedPlane) &&
    //            Vector3.Dot(DandelionAR.Instance.mainCamera.transform.position - coreHit.Pose.position,
    //                coreHit.Pose.rotation * Vector3.up) < 0)
    //        {
    //            Debug.Log("Hit at back of the current DetectedPlane");
    //            return false;
    //        }
    //        else
    //        {
    //            ReticleState = FocusState.Found;
    //            foundReticle.transform.position = coreHit.Pose.position;
    //            foundReticle.transform.rotation = coreHit.Pose.rotation;
    //            foundReticle.transform.LookAt(new Vector3(DandelionAR.Instance.mainCamera.transform.position.x, foundReticle.transform.position.y, DandelionAR.Instance.mainCamera.transform.position.z));
    //            return true;
    //        }
    //    }
    //    return false;
    //}
    //#endregion
}
